Steps:
-----
1. Create EKS cluster
3. Verify the cluster access
4. Create docker image with required app files
5. Push to docker repo
6. Creating kubernetes deployment
7. Test the scalability
8. Conclusion

TASK 1: Create EKS cluster
--------------------------
    Create VPC (Virtual Private Cloud)

    search VPC > select VPC service > your VPCs > Create VPC
    Create subnets
    Create Internet gateway > attach it to VPC
    Create Route table
        Select the created route table >> Routes > edit routes > add route 0.0.0.0/0 target internet gateway
                                        subnet association > edit subnet association > Add the subnets to allow
    Create IAM Role with Security group
    Create eks cluster master node
    Install & configure aws cli and kubectl
        Test the cluster access
    Setup worker nodes in EKS
        verify worker nodes status using kubectl
    
1. To create a new VPC:                                       
Doc:
For creating a VPC, search for VPC in the AWS services menu.

A VPC dashboard will be opened. Click on Create VPC.
img.1

In VPC settings, name your vpc (eks-cluster-vpc), and the remaining settings can be default or add your own IPv4 CIDR range for the vpc and select create vpc
VPC will be visible on the dashboard
img.2,3,4

2. Create subnets:
Click on subnets in the VPC drop-down. Click on Create Subnet.

Select the VPC created in the previous step, and in the subnet settings, add two AZs for high availability.
   
3. Create Internet gateway > attach it to VPC:
   

Click on Internet gateway in the VPC drop-down. Click on Create Internet gateway.

name the gateway as eks-ig1. Click on Create.

Now the IG has been created, we have to attach it to VPC. For that, click on Actions and select Attach to VPC.

4. Create Route table:

For creating Route tables, same like above select route tables from VPC dropdown and click on Create route table.

In the settings , name the table as eks-rt1 and select the VPC. Click on create.

Once the table is created, it will be visible in the route table dashboard

Next step is to edit the routes and add the subnets in subnet associations.

For editing the routes , select Routes > Edit routes > Add route > Destination as 0.0.0.0/0, Target - Internet Gateway, select the ig that we created. > save changes

For subnet associations , select Subnet associations > Edit subnet associations  > select the created subnets > save 

5. Create IAM Role with security group:

This is required for creating worker nodes, access to underlying networking, load balancer services etc..,
For creating IAM role , search for IAM in AWS services and then select Roles from Access management dropdown. Click on create

select AWS service as trusted entity and EKS-cluster as use case. Click on Next for Adding permissions

A policy name is attached by default AmazonEKSClusterPolicy, we can expand the policy to check what is allowed, click on next
 
Assing a role name called eks-role, click on create role and we can check it on the roles dashboard.


6. Create EKS cluster:

For creating EKS cluster, search for EKS in AWS services menu.

EKS dashboard will be opened, click on Add cluster and create

Now we have to provide the details for cluster configuration

Name your cluster as eks-cluster and select the cluster role which we had created in the previous step. click on Next.

In the network settings, select the VPC and the subnets. click on next and create the cluster.

Go back to eks clusters dashboard to check the status of the cluster, it takes 10-15 mins to be active.

Once the cluster is active, Verify the controlplane nodes using kubectl.
For that we have to install aws cli and kubectl on your laptops by referring steps from aws documentation.

Below are the steps to install AWS CLI:

Linux:
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
Windows:
msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi

Verify:
aws --version

Configure AWS credentials:
Go to AWS services menu and search for IAM and choose users and then choose credentials , create secret key.
Its only one time accessible to read so please download the file to the local system.

Open the terminal in tht laptop, and run the below command

aws configure



Install kubectl:

Refer kubernetes.io documentation for installing the kubectl on the laptop.
Run the below commands.

curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

validate the bindary 
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check

If valid, the output is:
kubectl: OK


sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
kubectl version --client

kubectl configuration:

1. check your cluster Name and region where EKS master node is Active. These details can be found on the EKS cluster dashboard.
Region : us-east-1
Name: eks-cluster

2. check cluster status using aws cli command

aws eks --region <region_name> describe-cluster --name <name> --query cluster.status

aws eks --region us-east-1 describe-cluster --name eks-cluster --query cluster.status

3. configure kubectl using below command, this adds a context on the kubeconfig. Then we will get access to the cluster
aws eks --region us-east-1 update-kubeconfig --name eks-cluster

4. Verify now by running kubectl commands
kubectl get svc -A


If the command returns any error,Verify the steps again.

Setup worker nodes in EKS:

Login to AWS console and go to eks cluster and click on compute.

To setup worker node, we have to add node group, it is collection of nodes which acting as worker nodes. Click on Add node group.

In the node group configuration, name the group as eks-workerng1 and here we have to select a IAM  role for worker nodes. 
Create a new IAM role as mentioned the  previous steps



-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
Deploying sample webpage in the cluster:

    1. Install docker engine to push/pull the images.
        
Below steps can be found in Docker documentation.
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

# Add the repository to Apt sources:https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
sudo service docker start

Once docker is installed, test the docker login by

docker login -u <username> -p <password>

Now we are ready to build an image and push to the docker repository.

Build docker image:

docker build -t srikanth7777/apache-html-sample:2 .
docker push  srikanth7777/apache-html-sample:2


Install k6 for load testing:

copied from kuberenets.io >>>
Previously we created a Deployment, and then exposed it publicly via a Service. 
The Deployment created only one Pod for running our application. 
When traffic increases, we will need to scale the application to keep up with user demand.


sudo gpg -k
sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6


Test: k6 run --vus 1000 --duration 3m load-test.js

kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

pavankumarseeram_pk@cloudshell:~/CKA/final_project/test2$ k6 run --vus 1000 --duration 5m load-test.js                         

          /\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  \/    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / __________ \  |__| \__\ \_____/ .io

  execution: local
     script: load-test.js
     output: -

  scenarios: (100.00%) 1 scenario, 1000 max VUs, 5m30s max duration (incl. graceful stop):
           * default: 1000 looping VUs for 5m0s (gracefulStop: 30s)


running (0m23.1s), 1000/1000 VUs, 24111 complete and 0 interrupted iterations
default   [=>------------------------------------] 1000 VUs  0m23.1s/5m0s


In other terminal, keep hpa in watch

pavankumarseeram_pk@cloudshell:~/CKA/final_project/test2$ k get hpa -w                                                         
NAME                     REFERENCE                           TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
apache-html-deployment   Deployment/apache-html-deployment   1%/50%    1         10        1          45m

apache-html-deployment   Deployment/apache-html-deployment   25%/50%   1         10        1          47m
apache-html-deployment   Deployment/apache-html-deployment   153%/50%   1         10        1          47m
apache-html-deployment   Deployment/apache-html-deployment   153%/50%   1         10        4          47m


https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/

kubectl run -i --tty load-generator --rm --image=busybox:1.28 \
--restart=Never -- /bin/sh -c "while sleep 0.01; do wget -q -O- http://html-app-deployment; done"

https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbHBneTV2ckZXMW1PSmlsaTg2RFBBVEk0a01RUXxBQ3Jtc0tuRzA0Umh4RHZEbWtWZE00c01KakFrczlONHhUZmJINHgyblprT29QNXJ4NEo1NldYVzhvNk9SMnV0RklYZ3dsVzlWVUdLX2U3cjJUS2tUY3ZmOGlTQkxNZVZZeVNLMXlUR29pSTJLVHV2S3dYQjU5dw&q=https%3A%2F%2Fdocs.aws.amazon.com%2Fcli%2Flatest%2Fuserguide%2Fcli-configure-files.html&v=p6xDCz00TxU
docker build -t your-image-name:tag .
docker push your-image-name:tag

deployment.yaml >

apiVersion: apps/v1
kind: Deployment
metadata:
  name: student-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: student-app
  template:
    metadata:
      labels:
        app: student-app
    spec:
      containers:
      - name: student-app
        image: your-image-name:tag
        ports:
        - containerPort: 5000

Service >

apiVersion: v1
kind: Service
metadata:
  name: student-app
spec:
  selector:
    app: student-app
  ports:
  - protocol: "TCP"
    port: 80
    targetPort: 5000
  type: LoadBalancer
